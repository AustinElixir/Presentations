Erlang Web Framework
Distribution Algoritms
	- Round Robin
	- Random
	- Cost Based
	- By Type
	- Profiling (time)

Distribution Benefits
	- Performance scaled with demand
	- Fault tolerance with replication
	- Federation of disparate services
	- Extensibility

Distributed Basics
	- A node is a VM
	- EPMD proccess on port 4369
	- >= 1 node per host
	- erl -sname NodeName for same subnet
	- erl -name NodeName@hostname for different subnets
	- As soon as a node is referred to it is connected
	- net_adm:ping(nodeName)
	- Fully Meshed

	- node() identifies yourself
	- nodes() to see a list of connected nodes
	- spawn/4 to run a function on a node
	- Any node can connect to another
	- erlang:is_alive() checks your ability to join a cluster
	- net_kernel controls erlang's distributed operations
	- code isn't automatically propagated

<lab exercise>

Security
	- cookie
	- use SSL over TCP/IP over non-secure networks
	- Rewrite net_kernel

<lab exercise>

Process ID Format
	Process id < A.B.C > is composed of:

	A, node id which is not arbitrary but the internal index for that node in dist_entry. It is the atom slot integer for the node name.
	B, process index which refers to the internal index in the proctab, (0 -> MAXPROCS).
	C, Serial which increases every time MAXPROCS has been reached.

Mailbox
	- Every process has a mailbox
	- receive to pull messages
	- flush() to empty the mailbox
	- <PID> ! Msg
	- ref()

<lab exercise>

RPC Calls
	- Calling functions on remote nodes
	- Loading code on remote nodes
	- Constructing your own RPC server process
	- Handling faults
		- after timeout
		- spawn_link/4
		- monitor
	- Using rpc:call(Node, Module, Function, Args)

Alternative Topologies
	- erl -sname node_name -hidden
	- net_kernel:connect(NodeName)

